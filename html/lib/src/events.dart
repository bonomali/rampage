// Copyright (c) 2019 the Rampage Project Authors.
// Please see the AUTHORS file for details. All rights reserved.
// Use of this source code is governed by a zlib license that can be found in
// the LICENSE file.

import 'dart:async';

import 'package:rampage_html/browser/html.dart' as impl;

//------------------------------------------------------------------------------
// Events
//------------------------------------------------------------------------------

/// The [Event] interface represents an event which takes place in the DOM.
///
/// An event can be triggered by the user action e.g. clicking the mouse button
/// or tapping keyboard, or generated by APIs to represent the progress of an
/// asynchronous task. It can also be triggered programmatically, such as by
/// calling the [HtmlElement.click] method of an element, or by defining the
/// event, then sending it to a specified target using
/// [EventTarget.dispatchEvent].
abstract class Event {
  /// The name of the event (case-insensitive).
  String get type;

  /// A reference to the target to which the event was originally dispatched.
  EventTarget get target;

  /// A reference to the currently registered target for the event.
  ///
  /// This is the object to which the event is currently slated to be sent; it's
  /// possible this has been changed along the way through retargeting.
  EventTarget get currentTarget;

  /// Whether the [Event] bubbles up through the DOM or not.
  bool get bubbles;

  /// Whether the [Event] is cancelable.
  bool get cancelable;

  /// Whether or not the [Event] can bubble across the boundary between the
  /// shadow DOM and the regular DOM.
  bool get composed;

  /// Cancels the [Event] (if it is [cancelable]).
  void preventDefault();

  /// For this particular [Event], no other listener will be called.
  ///
  /// Neither those attached on the same [Element], nor those attached on
  /// [Element]s which will be traversed later (in capture phase, for instance)
  void stopImmediatePropagation();

  /// Stops the propagation of [Event]s further along in the DOM.
  void stopPropagation();
}

/// Represents options for creating an [Event].
abstract class EventInit {
  /// Creates the [EventInit] options.
  factory EventInit({
    bool bubbles,
    bool cancelable,
    bool composed,
  }) = impl.EventInitImpl;

  /// Whether the [Event] bubbles up through the DOM or not.
  bool get bubbles;
  set bubbles(bool value);

  /// Whether the [Event] is cancelable.
  bool get cancelable;
  set cancelable(bool value);

  /// Whether or not the [Event] can bubble across the boundary between the
  /// shadow DOM and the regular DOM.
  bool get composed;
  set composed(bool value);
}

/// The [CustomEvent] interface represents events initialized by an application
/// for any purpose.
abstract class CustomEvent implements Event {
  /// Creates a [CustomEvent] with the given [type].
  ///
  /// The [eventInitDict] can be used to customize the behavior of the event
  /// as well as attaching data through [CustomEventInit.detail].
  factory CustomEvent(String type, [CustomEventInit eventInitDict]) =
      impl.CustomEventImpl;

  /// Any data passed when initializing the event.
  dynamic get detail;
}

/// Represents options for creating a [CustomEvent].
abstract class CustomEventInit implements EventInit {
  /// Creates the [CustomEventInit] options.
  factory CustomEventInit({
    bool bubbles,
    bool cancelable,
    bool composed,
    dynamic detail,
  }) = impl.CustomEventInitImpl;

  /// Data to pass to the event.
  dynamic get detail;
  set detail(dynamic value);
}

//------------------------------------------------------------------------------
// EventTarget
//------------------------------------------------------------------------------

/// [EventTarget] is a DOM interface implemented by objects that can receive
/// events and may have listeners for them.
abstract class EventTarget {
  /// [Event] streams for the target.
  ///
  /// Subscribe to a [Stream] by accessing it through the corresponding
  /// [Event.type].
  Map<String, Stream<Event>> get on;

  /// Dispatches an [Event] to this [EventTarget].
  bool dispatchEvent(Event event);
}
